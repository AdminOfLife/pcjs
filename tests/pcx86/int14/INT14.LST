Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-1
                                                            

                                	title	int14.asm 
                                	page	,120 
                                 
                                ;	By Jeff Parsons (@jeffpar) 2018-03-06 
                                ;	Installs interrupt handlers for the COM port associated with I/O address 0x2F8 (and IR
				Q 3). 
                                 
 0000                           code	segment word public 'code' 
                                 
 0100                           	org	100h 
                                 
                                	assume	cs:code, ds:code, es:code, ss:code 
                                 
 0100                           main	proc	near 
 0100  E9 0651 R                	jmp	install 
                                main	endp 
                                 
                                	assume	cs:code, ds:nothing, es:nothing, ss:nothing 
                                 
 = 02F8                         COMADR	equ	2F8h 
 = 0003                         COMIRQ	equ	3 
                                 
 0103  00 00 00 00              prev14	dd	0			; previous INT 14h handler 
 0107  FFFF                     comID	dw	-1			; 0-based index of our COM port in BIOS data area 
 0109  01                       rtsFlag	db	1			; internal RTS flag (0=off, 1=on) 
                                 
 = 0010                         MAXBUF	equ	16 
 010A  0010[                    inBuf	db	MAXBUF dup (?) 
            ??                  
                         ]      
                                
 011A  0010[                    outBuf	db	MAXBUF dup (?) 
            ??                  
                         ]      
                                
 012A  0000                     inTot	dw	0			; counts the total number of input bytes buffered 
 012C  010A R                   inHead	dw	offset inBuf 
 012E  010A R                   inTail	dw	offset inBuf 
 0130  011A R                   outHead	dw	offset outBuf 
 0132  011A R                   outTail	dw	offset outBuf 
                                 
 = 0100                         MAXLOG	equ	256 
 0134  0100[                    logBuff	db	MAXLOG dup (0) 
            00                  
                         ]      
                                
 0234  0134 R                   logNext	dw	offset logBuff 
                                 
                                log	macro	c,d 
                                	local	log1 
                                	push	bx 
                                	mov	bx,logNext 
                                	mov	byte ptr cs:[bx],c 
                                	mov	byte ptr cs:[bx+1],d 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-2
                                                            

                                	add	bx,2 
                                	cmp	bx,offset logBuff + MAXLOG 
                                	jb	log1 
                                	mov	bx,offset logBuff 
                                log1:	mov	byte ptr cs:[bx],'.' 
                                	mov	byte ptr cs:[bx+1],'.' 
                                	mov	logNext,bx 
                                	pop	bx 
                                	endm 
                                 
 0236                           inthw	proc	far 
 0236  FB                       	sti 
 0237  50                       	push	ax 
 0238  53                       	push	bx 
 0239  52                       	push	dx 
 023A  1E                       	push	ds 
 023B  0E                       	push	cs 
 023C  1F                       	pop	ds 
                                	assume	ds:code 
 023D  06                       	push	es 
 023E  BB 0040                  	mov	bx,40h 
 0241  8E C3                    	mov	es,bx 
 0243  8B 1E 0107 R             	mov	bx,comID 
 0247  03 DB                    	add	bx,bx 
 0249  26: 8B 17                	mov	dx,es:[bx] 
 024C  52                       	push	dx 
 024D  42                       	inc	dx 
 024E  42                       	inc	dx			; DX -> IIR 
 024F  EC                       	in	al,dx 
 0250  5A                       	pop	dx 
                                	log	'H',al 
 0251  53                     1 	push	bx
 0252  8B 1E 0234 R           1 	mov	bx,logNext
 0256  2E: C6 07 48           1 	mov	byte ptr cs:[bx],'H'
 025A  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 025E  83 C3 02               1 	add	bx,2
 0261  81 FB 0234 R           1 	cmp	bx,offset logBuff + MAXLOG
 0265  72 03                  1 	jb	??0000
 0267  BB 0134 R              1 	mov	bx,offset logBuff
 026A  2E: C6 07 2E           1 ??0000:	mov	byte ptr cs:[bx],'.'
 026E  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 0273  89 1E 0234 R           1 	mov	logNext,bx
 0277  5B                     1 	pop	bx
                                 
 0278  3C 02                    	cmp	al,02h			; THRE condition? 
 027A  75 05                    	jne	hw1			; no 
 027C  E8 04BC R                	call	tryOut			; yes, so see if we have something to write 
 027F  EB 07                    	jmp	short hw9 
                                 
 0281  3C 04                    hw1:	cmp	al,04h			; DR condition? 
 0283  75 03                    	jne	hw9 
 0285  E8 0461 R                	call	tryIn 
                                 
 0288  FA                       hw9:	cli 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-3
                                                            

 0289  B0 20                    	mov	al,20h			; EOI command 
 028B  E6 20                    	out	20h,al 
 028D  07                       	pop	es 
 028E  1F                       	pop	ds 
                                	assume	ds:nothing 
 028F  5A                       	pop	dx 
 0290  5B                       	pop	bx 
 0291  58                       	pop	ax 
 0292  CF                       	iret 
                                inthw	endp 
                                 
 0293                           int14	proc	far 
 0293  2E: 3B 16 0107 R         	cmp	dx,comID		; request for our COM port? 
 0298  74 03                    	je	i14a			; yes 
 029A  E9 03B6 R                	jmp	i14x			; no 
                                 
 029D  84 E4                    i14a:	test	ah,ah			; INIT function? 
 029F  75 2D                    	jne	i14b			; no 
                                	log	'N',al 
 02A1  53                     1 	push	bx
 02A2  2E: 8B 1E 0234 R       1 	mov	bx,logNext
 02A7  2E: C6 07 4E           1 	mov	byte ptr cs:[bx],'N'
 02AB  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 02AF  83 C3 02               1 	add	bx,2
 02B2  81 FB 0234 R           1 	cmp	bx,offset logBuff + MAXLOG
 02B6  72 03                  1 	jb	??0001
 02B8  BB 0134 R              1 	mov	bx,offset logBuff
 02BB  2E: C6 07 2E           1 ??0001:	mov	byte ptr cs:[bx],'.'
 02BF  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 02C4  2E: 89 1E 0234 R       1 	mov	logNext,bx
 02C9  5B                     1 	pop	bx
 02CA  E8 0504 R                	call	init 
 02CD  CF                       	iret 
                                 
 02CE  80 FC 01                 i14b:	cmp	ah,1			; WRITE function? 
 02D1  75 2D                    	jne	i14c			; no 
                                	log	'W',al 
 02D3  53                     1 	push	bx
 02D4  2E: 8B 1E 0234 R       1 	mov	bx,logNext
 02D9  2E: C6 07 57           1 	mov	byte ptr cs:[bx],'W'
 02DD  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 02E1  83 C3 02               1 	add	bx,2
 02E4  81 FB 0234 R           1 	cmp	bx,offset logBuff + MAXLOG
 02E8  72 03                  1 	jb	??0002
 02EA  BB 0134 R              1 	mov	bx,offset logBuff
 02ED  2E: C6 07 2E           1 ??0002:	mov	byte ptr cs:[bx],'.'
 02F1  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 02F6  2E: 89 1E 0234 R       1 	mov	logNext,bx
 02FB  5B                     1 	pop	bx
 02FC  E8 0550 R                	call	write			; add the character in AL to outBuf 
 02FF  CF                       	iret 
                                 
 0300  80 FC 02                 i14c:	cmp	ah,2			; READ function? 
 0303  75 56                    	jne	i14d			; no 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-4
                                                            

 0305  E8 05B5 R                	call	read			; remove next char from inBuf into AL 
                                	log	'R',al 
 0308  53                     1 	push	bx
 0309  2E: 8B 1E 0234 R       1 	mov	bx,logNext
 030E  2E: C6 07 52           1 	mov	byte ptr cs:[bx],'R'
 0312  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 0316  83 C3 02               1 	add	bx,2
 0319  81 FB 0234 R           1 	cmp	bx,offset logBuff + MAXLOG
 031D  72 03                  1 	jb	??0003
 031F  BB 0134 R              1 	mov	bx,offset logBuff
 0322  2E: C6 07 2E           1 ??0003:	mov	byte ptr cs:[bx],'.'
 0326  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 032B  2E: 89 1E 0234 R       1 	mov	logNext,bx
 0330  5B                     1 	pop	bx
                                	log	'r',ah 
 0331  53                     1 	push	bx
 0332  2E: 8B 1E 0234 R       1 	mov	bx,logNext
 0337  2E: C6 07 72           1 	mov	byte ptr cs:[bx],'r'
 033B  2E: 88 67 01           1 	mov	byte ptr cs:[bx+1],ah
 033F  83 C3 02               1 	add	bx,2
 0342  81 FB 0234 R           1 	cmp	bx,offset logBuff + MAXLOG
 0346  72 03                  1 	jb	??0004
 0348  BB 0134 R              1 	mov	bx,offset logBuff
 034B  2E: C6 07 2E           1 ??0004:	mov	byte ptr cs:[bx],'.'
 034F  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 0354  2E: 89 1E 0234 R       1 	mov	logNext,bx
 0359  5B                     1 	pop	bx
 035A  CF                       	iret 
                                 
 035B  80 FC 03                 i14d:	cmp	ah,3			; STATUS function? 
 035E  75 56                    	jne	i14x			; no, jump to previous handler 
 0360  E8 0600 R                	call	status 
                                	log	'S',al 
 0363  53                     1 	push	bx
 0364  2E: 8B 1E 0234 R       1 	mov	bx,logNext
 0369  2E: C6 07 53           1 	mov	byte ptr cs:[bx],'S'
 036D  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 0371  83 C3 02               1 	add	bx,2
 0374  81 FB 0234 R           1 	cmp	bx,offset logBuff + MAXLOG
 0378  72 03                  1 	jb	??0005
 037A  BB 0134 R              1 	mov	bx,offset logBuff
 037D  2E: C6 07 2E           1 ??0005:	mov	byte ptr cs:[bx],'.'
 0381  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 0386  2E: 89 1E 0234 R       1 	mov	logNext,bx
 038B  5B                     1 	pop	bx
                                	log	's',ah 
 038C  53                     1 	push	bx
 038D  2E: 8B 1E 0234 R       1 	mov	bx,logNext
 0392  2E: C6 07 73           1 	mov	byte ptr cs:[bx],'s'
 0396  2E: 88 67 01           1 	mov	byte ptr cs:[bx+1],ah
 039A  83 C3 02               1 	add	bx,2
 039D  81 FB 0234 R           1 	cmp	bx,offset logBuff + MAXLOG
 03A1  72 03                  1 	jb	??0006
 03A3  BB 0134 R              1 	mov	bx,offset logBuff
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-5
                                                            

 03A6  2E: C6 07 2E           1 ??0006:	mov	byte ptr cs:[bx],'.'
 03AA  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 03AF  2E: 89 1E 0234 R       1 	mov	logNext,bx
 03B4  5B                     1 	pop	bx
 03B5  CF                       	iret 
                                 
 03B6  2E: FF 2E 0103 R         i14x:	jmp	dword ptr [prev14] 
                                 
                                int14	endp 
                                 
                                ; 
                                ; fakeLSR 
                                ; 
                                ; Returns fake LSR in AL. 
                                ; 
 03BB                           fakeLSR	proc	near 
                                	assume	ds:code 
 03BB  53                       	push	bx 
 03BC  52                       	push	dx 
 03BD  83 C2 05                 	add	dx,5			; DX -> LSR 
 03C0  EC                       	in	al,dx 
                                	; 
                                	; See if inBuf contains data, and set the DR bit if it does. 
                                	; 
 03C1  24 FE                    	and	al,not 01h 
 03C3  8B 1E 012C R             	mov	bx,inHead 
 03C7  3B 1E 012E R             	cmp	bx,inTail 
 03CB  74 02                    	je	lsr1 
 03CD  0C 01                    	or	al,01h 
                                	; 
                                	; See if outBuf still has room, and set the THRE bit if it does. 
                                	; 
 03CF  24 DF                    lsr1:	and	al,not 20h 
 03D1  8B 1E 0130 R             	mov	bx,outHead 
 03D5  E8 044C R                	call	incPtr 
 03D8  3B 1E 0132 R             	cmp	bx,outTail 
 03DC  74 02                    	je	lsr9 
 03DE  0C 20                    	or	al,20h 
                                 
 03E0  5A                       lsr9:	pop	dx 
 03E1  5B                       	pop	bx 
 03E2  C3                       	ret 
                                fakeLSR	endp 
                                 
                                ; 
                                ; getLSR 
                                ; 
                                ; Returns LSR in AL. 
                                ; 
 03E3                           getLSR	proc	near 
                                	assume	ds:code 
 03E3  52                       	push	dx 
 03E4  83 C2 05                 	add	dx,5			; DX -> LSR 
 03E7  EC                       	in	al,dx			; AL = LSR bits 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-6
                                                            

 03E8  5A                       	pop	dx 
 03E9  C3                       	ret 
                                getLSR	endp 
                                 
                                ; 
                                ; getMSR 
                                ; 
                                ; Returns MSR in AL. 
                                ; 
 03EA                           getMSR	proc	near 
                                	assume	ds:code 
 03EA  52                       	push	dx 
 03EB  83 C2 06                 	add	dx,6			; DX -> MSR 
 03EE  EC                       	in	al,dx			; AL = MSR bits 
 03EF  5A                       	pop	dx 
 03F0  C3                       	ret 
                                getMSR	endp 
                                 
                                ; 
                                ; setIER 
                                ; 
                                ; Sets the physical IER bits. 
                                ; 
 03F1                           setIER	proc	near 
                                	assume	ds:code 
 03F1  52                       	push	dx 
 03F2  83 C2 03                 	add	dx,3			; DX -> LCR 
 03F5  EC                       	in	al,dx 
 03F6  EB 00                    	jmp	$+2 
 03F8  24 7F                    	and	al,not 80h		; make sure the DLAB is not set, so that we can set IER 
 03FA  EE                       	out	dx,al 
 03FB  4A                       	dec	dx 
 03FC  4A                       	dec	dx			; DX -> IER 
 03FD  B0 03                    	mov	al,03h			; enable RBR (01h) and THR (02h) COM interrupts 
 03FF  EE                       	out	dx,al 
 0400  5A                       	pop	dx 
 0401  C3                       	ret 
                                setIER	endp 
                                 
                                ; 
                                ; setDTR 
                                ; 
                                ; Sets the physical DTR bit. 
                                ; 
 0402                           setDTR	proc	near 
                                	assume	ds:code 
 0402  52                       	push	dx 
 0403  83 C2 04                 	add	dx,4			; DX -> MCR 
 0406  EC                       	in	al,dx 
 0407  EB 00                    	jmp	$+2 
 0409  0C 01                    	or	al,01h			; DTR == 01h 
 040B  EE                       	out	dx,al 
 040C  5A                       	pop	dx 
 040D  C3                       	ret 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-7
                                                            

                                setDTR	endp 
                                 
                                ; 
                                ; setRTS 
                                ; 
                                ; Sets the physical RTS bit according to the internal rtsFlag. 
                                ; 
 040E                           setRTS	proc	near 
                                	assume	ds:code 
 040E  50                       	push	ax 
 040F  52                       	push	dx 
 0410  83 C2 04                 	add	dx,4			; DX -> MCR 
 0413  EC                       	in	al,dx 
 0414  EB 00                    	jmp	$+2 
 0416  0C 02                    	or	al,02h			; RTS == 02h 
 0418  80 3E 0109 R 00          	cmp	rtsFlag,0 
 041D  75 02                    	jne	rts9 
 041F  24 FD                    	and	al,not 02h 
 0421  EE                       rts9:	out	dx,al 
                                	log	'T',al 
 0422  53                     1 	push	bx
 0423  8B 1E 0234 R           1 	mov	bx,logNext
 0427  2E: C6 07 54           1 	mov	byte ptr cs:[bx],'T'
 042B  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 042F  83 C3 02               1 	add	bx,2
 0432  81 FB 0234 R           1 	cmp	bx,offset logBuff + MAXLOG
 0436  72 03                  1 	jb	??0007
 0438  BB 0134 R              1 	mov	bx,offset logBuff
 043B  2E: C6 07 2E           1 ??0007:	mov	byte ptr cs:[bx],'.'
 043F  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 0444  89 1E 0234 R           1 	mov	logNext,bx
 0448  5B                     1 	pop	bx
 0449  5A                       	pop	dx 
 044A  58                       	pop	ax 
 044B  C3                       	ret 
                                setRTS	endp 
                                 
                                ; 
                                ; incPtr 
                                ; 
                                ; Updates BX to next buffer position. 
                                ; 
 044C                           incPtr	proc	near 
                                	assume	ds:code 
 044C  43                       	inc	bx 
 044D  81 FB 011A R             	cmp	bx,offset inBuf + MAXBUF 
 0451  75 04                    	jne	inc1 
 0453  BB 010A R                	mov	bx,offset inBuf 
 0456  C3                       inc0:	ret 
 0457  81 FB 012A R             inc1:	cmp	bx,offset outBuf + MAXBUF 
 045B  75 F9                    	jne	inc0 
 045D  BB 011A R                	mov	bx,offset outBuf 
 0460  C3                       	ret 
                                incPtr	endp 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-8
                                                            

                                 
                                ; 
                                ; tryIn 
                                ; 
                                ; If the DR bit is set, see if we can buffer the data. 
                                ; 
 0461                           tryIn	proc	near 
                                	assume	ds:code 
 0461  52                       	push	dx 
 0462  83 C2 05                 	add	dx,5			; DX -> LSR 
 0465  EC                       	in	al,dx 
 0466  5A                       	pop	dx 
 0467  A8 01                    	test	al,01h			; DR set? 
 0469  74 50                    	jz	ti9 
 046B  EC                       	in	al,dx			; AL == new data 
                                	log	'I',al 
 046C  53                     1 	push	bx
 046D  8B 1E 0234 R           1 	mov	bx,logNext
 0471  2E: C6 07 49           1 	mov	byte ptr cs:[bx],'I'
 0475  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 0479  83 C3 02               1 	add	bx,2
 047C  81 FB 0234 R           1 	cmp	bx,offset logBuff + MAXLOG
 0480  72 03                  1 	jb	??0008
 0482  BB 0134 R              1 	mov	bx,offset logBuff
 0485  2E: C6 07 2E           1 ??0008:	mov	byte ptr cs:[bx],'.'
 0489  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 048E  89 1E 0234 R           1 	mov	logNext,bx
 0492  5B                     1 	pop	bx
 0493  53                       	push	bx 
 0494  8B 1E 012C R             	mov	bx,inHead 
 0498  88 07                    	mov	[bx],al 
 049A  E8 044C R                	call	incPtr 
 049D  3B 1E 012E R             	cmp	bx,inTail 
 04A1  74 17                    	je	ti8			; buffer full, dropping the data 
 04A3  89 1E 012C R             	mov	inHead,bx 
 04A7  FF 06 012A R             	inc	inTot 
 04AB  83 3E 012A R 08          	cmp	inTot,MAXBUF/2		; have we reached the half-way point? 
 04B0  75 08                    	jne	ti8			; no 
 04B2  C6 06 0109 R 00          	mov	rtsFlag,0		; yes, so let's try turning RTS off 
 04B7  E8 040E R                	call	setRTS			; and hope the sender give us some space 
 04BA  5B                       ti8:	pop	bx 
 04BB  C3                       ti9:	ret 
                                tryIn	endp 
                                 
                                ; 
                                ; tryOut 
                                ; 
                                ; If we have some buffered data, and the THRE bit is set, output more data. 
                                ; 
 04BC                           tryOut	proc	near 
                                	assume	ds:code 
 04BC  53                       	push	bx 
 04BD  8B 1E 0132 R             	mov	bx,outTail 
 04C1  3B 1E 0130 R             	cmp	bx,outHead 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-9
                                                            

 04C5  74 3B                    	je	to9 
 04C7  52                       	push	dx 
 04C8  83 C2 05                 	add	dx,5			; DX -> LSR 
 04CB  EC                       	in	al,dx 
 04CC  5A                       	pop	dx 
 04CD  A8 20                    	test	al,20h			; THRE set? 
 04CF  74 31                    	jz	to9			; no 
 04D1  8A 07                    	mov	al,[bx] 
 04D3  EE                       	out	dx,al 
                                	log	'O',al 
 04D4  53                     1 	push	bx
 04D5  8B 1E 0234 R           1 	mov	bx,logNext
 04D9  2E: C6 07 4F           1 	mov	byte ptr cs:[bx],'O'
 04DD  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 04E1  83 C3 02               1 	add	bx,2
 04E4  81 FB 0234 R           1 	cmp	bx,offset logBuff + MAXLOG
 04E8  72 03                  1 	jb	??0009
 04EA  BB 0134 R              1 	mov	bx,offset logBuff
 04ED  2E: C6 07 2E           1 ??0009:	mov	byte ptr cs:[bx],'.'
 04F1  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 04F6  89 1E 0234 R           1 	mov	logNext,bx
 04FA  5B                     1 	pop	bx
 04FB  E8 044C R                	call	incPtr 
 04FE  89 1E 0132 R             	mov	outTail,bx 
 0502  5B                       to9:	pop	bx 
 0503  C3                       	ret 
                                tryOut	endp 
                                 
                                ; 
                                ; init 
                                ; 
                                ; Handles INIT requests from INT 14h. 
                                ; 
 0504                           init	proc	near 
 0504  53                       	push	bx 
 0505  52                       	push	dx 
 0506  1E                       	push	ds 
 0507  0E                       	push	cs 
 0508  1F                       	pop	ds 
                                	assume	ds:code 
 0509  9C                       	pushf 
 050A  FF 1E 0103 R             	call	dword ptr [prev14] 
 050E  50                       	push	ax 
 050F  06                       	push	es 
 0510  BB 0040                  	mov	bx,40h 
 0513  8E C3                    	mov	es,bx 
 0515  8B 1E 0107 R             	mov	bx,comID 
 0519  03 DB                    	add	bx,bx 
 051B  26: 8B 17                	mov	dx,es:[bx] 
 051E  C7 06 012A R 0000        	mov	inTot,0 
 0524  C7 06 012C R 010A R      	mov	inHead,offset inBuf 
 052A  C7 06 012E R 010A R      	mov	inTail,offset inBuf 
 0530  C7 06 0130 R 011A R      	mov	outHead,offset outBuf 
 0536  C7 06 0132 R 011A R      	mov	outTail,offset outBuf 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-10
                                                            

 053C  E8 03F1 R                	call	setIER 
 053F  E8 0402 R                	call	setDTR 
 0542  C6 06 0109 R 01          	mov	rtsFlag,1 
 0547  E8 040E R                	call	setRTS 
 054A  58                       	pop	ax 
 054B  07                       	pop	es 
 054C  1F                       	pop	ds 
                                	assume	ds:nothing 
 054D  5A                       	pop	dx 
 054E  5B                       	pop	bx 
 054F  C3                       	ret 
                                init	endp 
                                 
                                ; 
                                ; write 
                                ; 
                                ; Handles WRITE requests from INT 14h. 
                                ; 
                                ; If AH == 1 (the normal INT 14h write scenario), mimicking the ROM BIOS 
                                ; requires that we wait for DSR, then CTS, and finally THRE.  I would prefer 
                                ; to do that by spin-waiting for MSR-based and LSR-based interrupt triggers, 
                                ; rather than adopting the ROM's totally arbitrary "let's loop 64K times" for 
                                ; each condition.  But, as I'm sure the ROM BIOS authors originally thought 
                                ; too, this approach is easier. 
                                ; 
 0550                           write	proc	near 
 0550  53                       	push	bx 
 0551  51                       	push	cx 
 0552  52                       	push	dx 
 0553  1E                       	push	ds 
 0554  0E                       	push	cs 
 0555  1F                       	pop	ds 
                                	assume	ds:code 
 0556  06                       	push	es 
 0557  BB 0040                  	mov	bx,40h 
 055A  8E C3                    	mov	es,bx 
 055C  8B 1E 0107 R             	mov	bx,comID 
 0560  03 DB                    	add	bx,bx 
 0562  26: 8B 17                	mov	dx,es:[bx] 
                                 
 0565  FB                       	sti 
 0566  86 E0                    	xchg	ah,al			; stash the output data in AH 
 0568  2B C9                    	sub	cx,cx 
 056A  E8 03EA R                w1:	call	getMSR 
 056D  24 30                    	and	al,30h			; we're "cheating" and checking for both 
 056F  3C 30                    	cmp	al,30h			; DSR and CTS at once, instead of the ROM's 
 0571  74 0B                    	je	w2			; "one after the other" approach 
 0573  E2 F5                    	loop	w1 
 0575  E8 03E3 R                	call	getLSR 
 0578  0C 80                    	or	al,80h			; signal a time-out error 
 057A  86 E0                    	xchg	ah,al 
 057C  EB 31                    	jmp	short w9 
                                 
 057E  2B C9                    w2:	sub	cx,cx 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-11
                                                            

 0580  E8 03E3 R                w3:	call	getLSR 
 0583  A8 20                    	test	al,20h			; checking THRE 
 0585  75 08                    	jnz	w4 
 0587  E2 F7                    	loop	w3 
 0589  0C 80                    	or	al,80h			; signal a time-out error 
 058B  86 E0                    	xchg	ah,al 
 058D  EB 20                    	jmp	short w9 
                                 
 058F  FA                       w4:	cli 
 0590  2A C0                    	sub	al,al 
 0592  86 C4                    	xchg	al,ah			; recover the output data in AL and zero AH 
 0594  8B 1E 0130 R             	mov	bx,outHead 
 0598  88 07                    	mov	[bx],al 
 059A  E8 044C R                	call	incPtr 
 059D  3B 1E 0132 R             	cmp	bx,outTail 
 05A1  75 05                    	jne	w8 
 05A3  80 CC 80                 	or	ah,80h			; buffer full, so we pretend it's a time-out 
 05A6  EB 07                    	jmp	short w9 
                                 
 05A8  89 1E 0130 R             w8:	mov	outHead,bx		; there was room, so update the head ptr 
 05AC  E8 04BC R                	call	tryOut			; and since THRE was set, call tryOut 
                                 
 05AF  07                       w9:	pop	es 
 05B0  1F                       	pop	ds 
                                	assume	ds:nothing 
 05B1  5A                       	pop	dx 
 05B2  59                       	pop	cx 
 05B3  5B                       	pop	bx 
 05B4  C3                       	ret 
                                write	endp 
                                 
                                ; 
                                ; read 
                                ; 
                                ; Handles READ requests from INT 14h. 
                                ; 
 05B5                           read	proc	near 
 05B5  53                       	push	bx 
 05B6  52                       	push	dx 
 05B7  1E                       	push	ds 
 05B8  0E                       	push	cs 
 05B9  1F                       	pop	ds 
                                	assume	ds:code 
 05BA  06                       	push	es 
 05BB  BB 0040                  	mov	bx,40h 
 05BE  8E C3                    	mov	es,bx 
 05C0  8B 1E 0107 R             	mov	bx,comID 
 05C4  03 DB                    	add	bx,bx 
 05C6  26: 8B 17                	mov	dx,es:[bx] 
                                 
 05C9  86 E0                    	xchg	ah,al 
 05CB  E8 03E3 R                	call	getLSR 
 05CE  86 C4                    	xchg	al,ah 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-12
                                                            

 05D0  8B 1E 012E R             	mov	bx,inTail 
 05D4  3B 1E 012C R             	cmp	bx,inHead 
 05D8  75 05                    	jne	r1 
 05DA  80 CC 80                 	or	ah,80h 
 05DD  EB 1C                    	jmp	short r9 
                                 
 05DF  8A 07                    r1:	mov	al,[bx] 
 05E1  E8 044C R                	call	incPtr 
 05E4  89 1E 012E R             	mov	inTail,bx 
 05E8  83 3E 012A R 08          	cmp	inTot,MAXBUF/2		; are we at the half-way point? 
 05ED  75 08                    	jne	r8			; no 
 05EF  C6 06 0109 R 01          	mov	rtsFlag,1		; yes, so we must have turned RTS off 
 05F4  E8 040E R                	call	setRTS			; so let's turn RTS back on 
 05F7  FF 0E 012A R             r8:	dec	inTot 
                                 
 05FB  07                       r9:	pop	es 
 05FC  1F                       	pop	ds 
                                	assume	ds:nothing 
 05FD  5A                       	pop	dx 
 05FE  5B                       	pop	bx 
 05FF  C3                       	ret 
                                read	endp 
                                 
                                ; 
                                ; status 
                                ; 
                                ; Handles STATUS requests from INT 14h. 
                                ; 
                                ; We could pass STATUS requests on to the previous handler, but that would 
                                ; return the port's "raw" state, whereas we need to return our own simulated 
                                ; "buffered" state: LSR (reg #5) bits in AH, MSR (reg #6) bits in AL. 
                                ; 
                                ; It's worth noting what DOS really cares about from this call.  Prior to 
                                ; reading serial input, DOS calls the STATUS function and then requires that 
                                ; both AH bit 0 (LSR Data Ready: 0x01) and AL bit 5 (MSR Data Set Ready: 0x20) 
                                ; be set before it will call READ. 
                                ; 
                                ; Also, in some cases (eg, the CTTY case), DOS requires that both AH bit 5 
                                ; (LSR Transmitter Holding Register Empty: 0x20) and AL bit 5 (MSR Data Set 
                                ; Ready: 0x20) be set before it calls WRITE, while in other cases (eg, output 
                                ; redirection), DOS simply calls WRITE and hopes for the best. 
                                ; 
 0600                           status	proc	near 
 0600  53                       	push	bx 
 0601  52                       	push	dx 
 0602  1E                       	push	ds 
 0603  0E                       	push	cs 
 0604  1F                       	pop	ds 
                                	assume	ds:code 
 0605  06                       	push	es 
 0606  BB 0040                  	mov	bx,40h 
 0609  8E C3                    	mov	es,bx 
 060B  8B 1E 0107 R             	mov	bx,comID 
 060F  03 DB                    	add	bx,bx 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-13
                                                            

 0611  26: 8B 17                	mov	dx,es:[bx] 
 0614  E8 03BB R                	call	fakeLSR 
 0617  8A E0                    	mov	ah,al			; AH = LSR bits 
 0619  E8 03EA R                	call	getMSR			; AL = MSR bits 
 061C  07                       	pop	es 
 061D  1F                       	pop	ds 
                                	assume	ds:nothing 
 061E  5A                       	pop	dx 
 061F  5B                       	pop	bx 
 0620  C3                       	ret 
                                status	endp 
                                 
 0621  90                       	even 
 0622                           endRes	label	byte			; end of resident code/data 
                                 
 0622  43 4F 4D 3F 20 68 61     comMsg	db	"COM? handlers installed",13,10,'$' 
       6E 64 6C 65 72 73 20     
       69 6E 73 74 61 6C 6C     
       65 64 0D 0A 24           
 063C  43 4F 4D 20 70 6F 72     errMsg	db	"COM port not found",13,10,'$' 
       74 20 6E 6F 74 20 66     
       6F 75 6E 64 0D 0A 24     
                                 
 0651                           install	proc	near 
                                	assume	ds:code, es:code, ss:code 
 0651  2B C0                    	sub	ax,ax 
 0653  8E C0                    	mov	es,ax 
                                	assume	es:nothing		; since ES is zero 
                                 
 0655  BB 0400                  	mov	bx,400h			; we'll access the RBDA at 0:400 instead of 40:0 
 0658  2B D2                    	sub	dx,dx 
 065A  26: 81 3F 02F8           i1:	cmp	word ptr es:[bx],COMADR	; match? 
 065F  74 11                    	je	i2			; yes 
 0661  43                       	inc	bx 
 0662  43                       	inc	bx 
 0663  42                       	inc	dx 
 0664  80 FA 04                 	cmp	dl,4 
 0667  72 F1                    	jb	i1 
 0669  BA 063C R                	mov	dx,offset errMsg 
 066C  B4 09                    	mov	ah,09h 
 066E  CD 21                    	int	21h 
 0670  CD 20                    	int	20h 
                                 
 0672  89 16 0107 R             i2:	mov	comID,dx 
 0676  26: C7 06 002C 0236      	mov	word ptr es:[(08h+COMIRQ)*4],offset inthw 
        R                       	mov	word ptr es:[(08h+COMIRQ)*4],offset inthw 
 067D  26: 8C 0E 002E           	mov	es:[(08h+COMIRQ)*4+2],cs 
 0682  26: 8B 17                	mov	dx,es:[bx] 
 0685  E8 03F1 R                	call	setIER 
 0688  E8 0402 R                	call	setDTR 
 068B  E8 040E R                	call	setRTS			; rtsFlag is initially 1 
 068E  E4 21                    	in	al,21h 
 0690  EB 00                    	jmp	$+2 
 0692  24 F7                    	and	al,not (1 shl COMIRQ) 
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Page     1-14
                                                            

 0694  E6 21                    	out	21h,al			; unmask the appropriate COM IRQ 
                                 
 0696  B8 0293 R                	mov	ax,offset int14 
 0699  26: 87 06 0050           	xchg	ax,es:[14h*4] 
 069E  A3 0103 R                	mov	word ptr prev14,ax 
 06A1  8C C8                    	mov	ax,cs 
 06A3  26: 87 06 0052           	xchg	ax,es:[14h*4+2] 
 06A8  A3 0105 R                	mov	word ptr prev14+2,ax 
                                 
 06AB  8B 16 0107 R             	mov	dx,comID 
 06AF  80 C2 31                 	add	dl,'1' 
 06B2  88 16 0625 R             	mov	comMsg+3,dl 
 06B6  BA 0622 R                	mov	dx,offset comMsg 
 06B9  B4 09                    	mov	ah,09h 
 06BB  CD 21                    	int	21h 
                                 
 06BD  BA 0622 R                	mov	dx,offset endRes 
 06C0  CD 27                    	int	27h 
                                install	endp 
                                 
 06C2                           code	ends 
                                 
                                	end	main 

Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Symbols-1
                                                             

Macros:

		N a m e			Lines

LOG  . . . . . . . . . . . . . .  	  12

Segments and Groups:

                N a m e         	Size	Align	Combine Class

CODE . . . . . . . . . . . . . .  	06C2	WORD	PUBLIC	'CODE'

Symbols:            

                N a m e         	Type	Value	Attr         

COMADR . . . . . . . . . . . . .  	Number	02F8	
COMID  . . . . . . . . . . . . .  	L WORD 	0107	CODE
COMIRQ . . . . . . . . . . . . .  	Number	0003	
COMMSG . . . . . . . . . . . . .  	L BYTE 	0622	CODE

ENDRES . . . . . . . . . . . . .  	L BYTE 	0622	CODE
ERRMSG . . . . . . . . . . . . .  	L BYTE 	063C	CODE

FAKELSR  . . . . . . . . . . . .  	N PROC	03BB	CODE	Length = 0028

GETLSR . . . . . . . . . . . . .  	N PROC	03E3	CODE	Length = 0007
GETMSR . . . . . . . . . . . . .  	N PROC	03EA	CODE	Length = 0007

HW1  . . . . . . . . . . . . . .  	L NEAR	0281	CODE
HW9  . . . . . . . . . . . . . .  	L NEAR	0288	CODE

I1 . . . . . . . . . . . . . . .  	L NEAR	065A	CODE
I14A . . . . . . . . . . . . . .  	L NEAR	029D	CODE
I14B . . . . . . . . . . . . . .  	L NEAR	02CE	CODE
I14C . . . . . . . . . . . . . .  	L NEAR	0300	CODE
I14D . . . . . . . . . . . . . .  	L NEAR	035B	CODE
I14X . . . . . . . . . . . . . .  	L NEAR	03B6	CODE
I2 . . . . . . . . . . . . . . .  	L NEAR	0672	CODE
INBUF  . . . . . . . . . . . . .  	L BYTE 	010A	CODE	Length = 0010
INC0 . . . . . . . . . . . . . .  	L NEAR	0456	CODE
INC1 . . . . . . . . . . . . . .  	L NEAR	0457	CODE
INCPTR . . . . . . . . . . . . .  	N PROC	044C	CODE	Length = 0015
INHEAD . . . . . . . . . . . . .  	L WORD 	012C	CODE
INIT . . . . . . . . . . . . . .  	N PROC	0504	CODE	Length = 004C
INSTALL  . . . . . . . . . . . .  	N PROC	0651	CODE	Length = 0071
INT14  . . . . . . . . . . . . .  	F PROC	0293	CODE	Length = 0128
INTAIL . . . . . . . . . . . . .  	L WORD 	012E	CODE
INTHW  . . . . . . . . . . . . .  	F PROC	0236	CODE	Length = 005D
INTOT  . . . . . . . . . . . . .  	L WORD 	012A	CODE

LOGBUFF  . . . . . . . . . . . .  	L BYTE 	0134	CODE	Length = 0100
LOGNEXT  . . . . . . . . . . . .  	L WORD 	0234	CODE
LSR1 . . . . . . . . . . . . . .  	L NEAR	03CF	CODE
Microsoft (R) Macro Assembler  Version 4.00                 3/7/18 08:57:28
 
int14.asm                                                   Symbols-2
                                                             

LSR9 . . . . . . . . . . . . . .  	L NEAR	03E0	CODE

MAIN . . . . . . . . . . . . . .  	N PROC	0100	CODE	Length = 0003
MAXBUF . . . . . . . . . . . . .  	Number	0010	
MAXLOG . . . . . . . . . . . . .  	Number	0100	

OUTBUF . . . . . . . . . . . . .  	L BYTE 	011A	CODE	Length = 0010
OUTHEAD  . . . . . . . . . . . .  	L WORD 	0130	CODE
OUTTAIL  . . . . . . . . . . . .  	L WORD 	0132	CODE

PREV14 . . . . . . . . . . . . .  	L DWORD	0103	CODE

R1 . . . . . . . . . . . . . . .  	L NEAR	05DF	CODE
R8 . . . . . . . . . . . . . . .  	L NEAR	05F7	CODE
R9 . . . . . . . . . . . . . . .  	L NEAR	05FB	CODE
READ . . . . . . . . . . . . . .  	N PROC	05B5	CODE	Length = 004B
RTS9 . . . . . . . . . . . . . .  	L NEAR	0421	CODE
RTSFLAG  . . . . . . . . . . . .  	L BYTE 	0109	CODE

SETDTR . . . . . . . . . . . . .  	N PROC	0402	CODE	Length = 000C
SETIER . . . . . . . . . . . . .  	N PROC	03F1	CODE	Length = 0011
SETRTS . . . . . . . . . . . . .  	N PROC	040E	CODE	Length = 003E
STATUS . . . . . . . . . . . . .  	N PROC	0600	CODE	Length = 0021

TI8  . . . . . . . . . . . . . .  	L NEAR	04BA	CODE
TI9  . . . . . . . . . . . . . .  	L NEAR	04BB	CODE
TO9  . . . . . . . . . . . . . .  	L NEAR	0502	CODE
TRYIN  . . . . . . . . . . . . .  	N PROC	0461	CODE	Length = 005B
TRYOUT . . . . . . . . . . . . .  	N PROC	04BC	CODE	Length = 0048

W1 . . . . . . . . . . . . . . .  	L NEAR	056A	CODE
W2 . . . . . . . . . . . . . . .  	L NEAR	057E	CODE
W3 . . . . . . . . . . . . . . .  	L NEAR	0580	CODE
W4 . . . . . . . . . . . . . . .  	L NEAR	058F	CODE
W8 . . . . . . . . . . . . . . .  	L NEAR	05A8	CODE
W9 . . . . . . . . . . . . . . .  	L NEAR	05AF	CODE
WRITE  . . . . . . . . . . . . .  	N PROC	0550	CODE	Length = 0065

??0000 . . . . . . . . . . . . .  	L NEAR	026A	CODE
??0001 . . . . . . . . . . . . .  	L NEAR	02BB	CODE
??0002 . . . . . . . . . . . . .  	L NEAR	02ED	CODE
??0003 . . . . . . . . . . . . .  	L NEAR	0322	CODE
??0004 . . . . . . . . . . . . .  	L NEAR	034B	CODE
??0005 . . . . . . . . . . . . .  	L NEAR	037D	CODE
??0006 . . . . . . . . . . . . .  	L NEAR	03A6	CODE
??0007 . . . . . . . . . . . . .  	L NEAR	043B	CODE
??0008 . . . . . . . . . . . . .  	L NEAR	0485	CODE
??0009 . . . . . . . . . . . . .  	L NEAR	04ED	CODE


    589 Source  Lines
    709 Total   Lines
     95 Symbols

  47024 Bytes symbol space free

      0 Warning Errors
      0 Severe  Errors
